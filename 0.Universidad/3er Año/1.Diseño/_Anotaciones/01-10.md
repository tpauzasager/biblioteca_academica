HandleBars --> Tamplate Engine (capa de modelo)
Patrón de repositorios --> ORM 
Internet == Cliente (decir cliente no internet)

Temas:
	Sesión
	Cookies
	Patrones de interacción 
	Clientes pesados y livianos 
	SPA
	Diagrama de componentes y despliegue 
	Escalabilidad 
	otros
___
# Sesión 
- Para identificar al usuario que intenta acceder al recurso
- Almacenar temporalmente información relacionada a las actividades 
___
# Cookies
Archivo pequeño que se guarda del lado del cliente, que almacena info de las pág web visitadas 
Se usan mucho con fines estadisticos 
Definición:
	- Pequeño archivo (servidor decide crear cookie, pero se guarda en cliente)
	- Sirven para identificar al usuario que realiza la request 
___
# Stateless vs Stateful
OBJETOS
Stateless:
	- Componente sin estado, aislado
	- No se almacena info de cada operación anterior (o si hay, no afecta a la operacion actual)
	- Cada operación se lleva a cabo desde cero (como si fuera la primera vez)
Stateful:
	- Se pueden volver una y otra vez (recuerda quienes somos)
	- Contexto guarda operaciones anteriores y esta afecta al proceso actual 

WEB
Stateless:
	- No se almacena sesión del lado del servidor  (NO EXISTE CONCEPTO DE SESIÓN)
	- Usuario se identifica en cada solicitud
	- Para identificarse, se envían token al servidor (JWT o propio del servidor) <-- Viajan en Header
	- En cada request se decodifica el token para identificar al usuario
	- Token tiene datos almacenados (que se obtienen al decodificar) 
	- Token tiene fecha de vencimiento y requiere mecanismo para crear uno nuevo 
	- Más performante a nivel uso de memoria
Stateful:
	- Se almacena sesión en el servidor 
	- Usuario se identifica una sola vez (no es cada solicitud)
	- En posteriores solicitudes, servidor revisa cookies del usuario y recupera sesión por id
	- Se le otorga un espacio de almacenamiento para la sesión y se otorga un id seteado en la cookie
	- Más performante a nivel procesamiento 
___
![[Pasted image 20241001090828.png]]

___
# Recursos en Sistemas Web
- Para poder identificar los recursos que debén exponerse, se tienen en cuenta los casos de usos 
Tipos:
	Dependientes (anidados):
		- No son autonomos (dependen de la existencia de otros)
		- No tiene sentido listarlas sin que sean condicionados por recurso contenedor 
		- Relación de composición 
	Independiente (autonomos):
		- No depende de nadie
___
# Grupo de rutas Javalin
![[Pasted image 20241001094206.png]]
___
# Protección de Recursos
Posibles niveles:
	1. Autenticación
	2. Autorización por roles
	3. Autorización por roles y permisos 

Autenticación:
	Evitar guardar permisos (hasta id y rol está bien)
	Exige que usuario se utentique antes de acceder a los recursos 
	Visual: Se puede redirigir a ruta de login si quiere acceder a ruta protegida 
	REST: Devolver 401 (no autorizado)
	Javalin:
```java
String idUsuario = context.sessionAttribute("idUsuario"); //idUsuario fue seteado anteriormente en la cookie
if idUsuario == null{
	context.redirect("/login?next=prodcutos"); //query param para que, luego de autenticarse, lo mande de nuevo a la página anterior
	return;
}
```

Autenticación por roles:
	Se requiere que el usuario se identifique (utiliza método autenticación)

```java
TipoRol rol = TipoRol.valueOf(context.sessionAttribute("rol"));
if(!rol.equals(TipoRol.SELLER)){
	context.redirect("/prihibido");
	return;
}
```

Autenticación por roles y permisos:
	Requiere protección por autenticación 
	Alcance:
		Cuales recursos a los que tiene acceso (por rol y permiso), puedo ver? 
		Tipos: Propio, propios, todos
___
# Handlers (Errores)
Los handlers se settean antes de hacer el init del Router (ver código de clase)
```java
## HandleBar
if(!rol = TipoRol.valueOf(...)){
	throw new AccessDeniedException //AccessDeniedException implements RunTimeException
}

## AccessDeniedHandler
public class AccessDeniedHandler {
	public void setHandler(Javalin app){ // la e es la excepción 
		app.exception(AccessDeniedException.class, (e, context) -> {
			context.status(401);
			context.render("401.hbs");
		})
	}
}
## AppHandler
```
___
# Middle Wares
Capa que se antepone a la capa de controllers 

Se puede agregar un roll en el app.get("", model, enumClass.ENUMTYPE, enumClass.ENUMTYPE, ...) 
Así declaro que solo esos roles pueden accedera  estas rutas 
Se inicializan antes de los los handlers 
Express -> JavaScript
Laravel -> Php
___
# MVVM
Modelo - Vista - VistaModelo
No se tienen controllers 
Angular trabaja con este modelo 
ViestaModelo puede modificar a ambos directamente 
___
# MVP
Modelo - Vista - Presentador
![[Pasted image 20241001111733.png]]
___
# Tipos de Clientes
Delegar quien se encarga de generar las vistas 
## Liviano
- Trabaja con servidor stateful(tiene sesiones) 
- Vista generado en el servidor
- Respuestas son (casi siempre) HTML
- Puede contener contenido lógica js del lado del cliente 
## Pesado 
- Trabaja con servidor stateless (usa tokens)
- Vistas generadas en Cliente
- Respuesta son Json
- Cliente posee toda lógica para presentar datos mediante JavaScript
___
# SPA: Single Page Application
Solo una página index.html
En la aplicación hay varias vistas dentro de la página index 
Para pasar de una vista a la otra, se ocultan y muestras las vistas necesarias 
SPA es cliente Pesado (pero no todo cliente pesado es SPA)
![[Pasted image 20241001115323.png]]
___
# Diagrama de Compotentes
___
# Diagrama de Despliegue 
Elementos 
	...
___
# Diagrama Despliegue + Componentes
Nodos:
	... 
___
# Escalabilidad
Extensiblidad pero para arquitectura
Crecer Verticalmente:
	Agregar más recursos físicos al servidor (para atender más solicitudes)
	Tiene limitación física
	No soluciona Disponiblidad, solo soluciona Performance 
Crecer Horizontalmente:
	Agregar más equipos para atender al servidor 
	No hay limitación física (pero se tiene que distribuir equitativamente entre servidores)
	Hace falta un balanceador de Cargas (que distribuya solicitudes entre equipos)
	Complejidad a la hora de manejar sesiones para los diferentes servidores (si es cliente liviano)
	Soluciona Disponibilidad y Performance 
___
# Tradeoffs entre Atributos de Calidad
Eficiencia de Desempeño - Uso de recursos (Performance)
Fiabilidad - Disponibilidad
Fiabilidad - Tolerancia a Fallos
Seguridad (en gral)

Algunos conflictos:
Perfonmance vs Seguridad
Seguridad vs Disponibilidad
Performance vs Modificabilidad 
