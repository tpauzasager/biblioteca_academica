1.a. Verdadero
1.b. 

2.a.

2.b.

| Nombre          | Dirty | Repeatable | Phantom |
| --------------- | ----- | ---------- | ------- |
| Read uncommited | SI    | NO         | SI      |
| Read commited   | NO    | NO         | SI      |
| Repeatable      | NO    | SI         | SI      |
| Serializable    | NO    | SI         | NO      |
Conviene usar el read uncommited cuando el resultado de las filas no importe para lo que se esté haciendo
Conviene usar serializable cuando los procesos a ejecutar sobre la/s tablas afectadas puedan llegar a ser comprometidas por la aparición de nuevas filas que no hayan sido insertadas por la propia transacción 
___
3.
Numeros(
	clave int PK,
	valor int
)

3.a. Realizar trigger de insert que valide que los valores del cambpo clave sean consecutivos desde el 1. Se sabe que posee un trigger de instead of que no puede modificarse y una Constaint parqa que no tome valores no positivos. 

```sql
CREATE TRIGGER validarClave
ON Numeros 
AFTER INSERT
AS BEGIN
	DECLARE @minNew INT, @maxNew INT, @cantNew INT;

	SELECT @minNew=MIN(valor), @maxNew=MAX(valor), @cantNew=COUNT(*)
		FROM inserted

	IF (NOT (EXISTS (SELECT * FROM Numeros WHERE valor=@minNew-1)) OR (@maxNew - @minNew +1 != @cantNew)
	BEGIN
		RAISERROR('Valor de claves no continuo', 16,1)
		ROLLBACK TRANSACTION
	END

END
```
3.b. Realizar trigger de insert que valide que datos no nulos del campo valor sean únicos. Explicar porque no se puede desarrollar esta función a través de Constraint unique. 
```sql
CREATE TRIGGER validarValor 
ON Numeros 
AFTER INSERT 
AS BEGIN
	DECLARE @newVal INT, @newCla INT;
	DECLARE cur CURSOR 
		FOR SELECT * FROM inserted 

	FETCH NEXT FROM cur INTO @newVal, @newCla;

	WHILE @@FETCH_STATUS = 0
	BEGIN
		IF EXISTS (SELECT * FROM Numeros WHERE valor=@newVal AND clave!=@newCla)
		BEGIN
			RAISERROR('Valor no valido'. 16,1);
			ROLLBACK;
		END
		FETCH NEXT FROM cur INTO @newVal, @newCla;
	END
END
```