![[Pasted image 20241002121353.png]]
# Práctiva
```cpp
almacen_disponible = 33
tunel_disponible = 2
mu_almacen = 1

mu_puede_recibir_entrega = [1,1,1...] //para que no se de el caso que dos distribuidores quieran entregar al mismo tiempo 
entregado = [0,0,0...]

hay_entrega = 0


FÁBRICA (1 instancia)
while(1){
	caja = fabricarMuniciones()

	w(almacen_disponible)
	w(tunel_disponible)
	w(mu_almacen)
	depositar(almacén, caja)
	s(mu_almacen)
	s(tunel_disponible)
	s(hay_entrega)
}

DISTRIBUIDOR (5 instancias)
while(1){
	w(hay_entrega)	
	w(tunel_disponible)
	w(mu_almacen)
	caja = retirar(almacén)
	s(mu_almacen)
	s(tunel_disponible)
	s(almacen_disponible)

	id_sent = getDestino(caja)

	w(mu_puede_recibir_entrega[id_sent])
	entregar(lider[id_asent], caja)
	s(mu_puede_recibir_entrega[id_sent])
	s(entregado[id_asent])
}

ASENTAMIENTO (10 instancias)
while(1){
	id_sent = getID()
	
	w(entregado[id_sent])
	caja = recibir(lider[id_asent])
	
	cargarArmas()
}
```
1.
	Mayor control al usar syscalls directamente
	Con wrappers hay mayor simplicidad y portabilidad
	Ej: open - fopen 
2. 
	16 procesadores divididos en 4 grupos (uno para cada tipo de proceso), en donde se crearan los ULTs correspondientes a cada proceso (otorgando mayor perzonalizar la planificación de los mismo). 
3. 
   Ninguno genera starvation
4. -
	