![[Pasted image 20241004174007.png]]
# Práctica
3. 
   a. Si. Todos
   b. Si. Agregando un R1 y que lo tome el P4
   c.
1. 
```cpp
copia_disponible = [20,20,20,20,20]

m_retiros = [1,1,1,1,1]
m_reservas = 1
m_devoluciones = 1
m_contFestejo = 1

hay_disponible = [0,0,0,0,0]
hay_devolucion = 0

CLIENTE (n instancias)
	libro = elegirLibro()
	w(copias_disponibles[libro.id])
	
	w(m_reservas)
	agregar(reservas, libro)
	s(m_reservas)
	s(hay_reserva)	

	w(hay_disponible[libro.id])
	irABiblioteca()
	
	w(m_retiros[libro.id])
	retirar(retiros[libro.id])
	s(m_retiros[libro.id])
	
	estudiar()
	
	irABiblioteca()
	
	w(m_devoluciones)
	agregar(devoluciones,libro)
	s(m_devoluciones)
	s(hay_devolucion)

////////////////////////////////////////////////////	
RESERVAS (2 instancias)
	w(hay_reserva)	
	w(m_reservas)
	libro = tomar(reservas)
	s(m_reservas)

	w(m_retiros[libro.id])
	agregar(libro,retiros[libro.id])
	s(m_retiros[libro.id])
	s(hay_disponible[libro.id])
	
////////////////////////////////////////////////////	
DEVOLUCIONES (2 instancias)
	w(hay_devolucion)
	w(m_devoluciones)
	libro = tomar(devoluciones)
	s(m_devoluciones)
	
	registrarDisponibles()
	s(copia_disponible[libro.id])
	
	//dentro tiene w/s(m_contFestejo) rodeando el uso de contFestejo
	if(...){...}
	else{...}
```
1. 
   a. HRRN. 
	   T=7: K3 cuanto con una rafaga de 7, pero $RR(K3,t=7)=(7+4)/7=1,57 > 1,5 = RR(K2)$ 
	   T=14: K2 tiene mayor RR que K1 (porque tienen misma rafaga, pero estuvo esperando más tiempo)
   b. Podría ocurrir que un proceso monopolice la CPU, ya que, no se cuenta con un algoritmo de desalojo. Mucho overhead por tener que calcular el RR cada vez que se debe tomar una decisión para replanificar (ademas se deberá estimar la rafaga de CPU)
   c. SJF, RR(Q>1), FIFO
___
# Teoría
1. 
   Debído a que las syscalls son procesadas por el SO, es necesario hace un cambio de contexto (guardar registros en pila del sistema y cargar los correspondientes a rutina del SO) y, en el caso de encontrarse en modo usuario, tambien hace falta cambio de modo. Luego se procede con la ejecución de las instrucciones necesarias para el procesamiento de la syscall.
   Si la interrupción no es enmascarable, será neceario ralizar otro cambio de contexto, pero no de modo (ya que se encontraría en modo kernel por la ejecución de la syscall). Si la interrupción es enmascarable, puede darse el caso de que se espere a que el procesamiento de la syscall termine antes de procesar dicha interrupción.
2. 
   a. Falso. Los cambios entre ULTs del mismo procesos si son realizados en modo usuario, en cambio, si los hilos son de procesos diferentes si es necesario realizar el cambio en modo Kernel (ya que es el SO el que lo maneja)
   b. Verdadero. Debía a que el SO no conoce la existencia de los ULTs, este no podría planificarlos, por lo que no se podrían ejecutar varios hilos en paralelo. En cambio, los KLTs si son conocidos por el SO, por lo que se podrían planificar y ejecutar en paralelo. 
3. 
   1ra cola (mayor prioridad): FIFO, ingresan aquellos procesos con una prioridad igual o mayor a la que se determine como "critica". 
   2da cola (menor prioridad): VRR (Q = rafaga promedio de CPU DE los IO bound), ingresan aquellos procesos que no clasifiquen para la 1ra cola. 
4. 
   La condición de carrera ocurre cuando al menos un proceso pretende modificar un recurso compartido y otro proceso está interesado en ese mismo recurso. Esto genera que el programa no sea deterministico, ya que, el resultado dependerá del orden en el que se ejecuten estos procesos.
   ```cpp
	PROCESO A
	while(1){
	recurso = getRecursoCompartido();
	recurso++;
	guardarRecursoCompartido(recurso);
	}

	PROCESO B
	while(1){
	recurso = getRecursoCompartido();
	printf("recurso: %v", recurso);
	}
	```
	Es un problema dificil de detectar observando unicamente la ejecución debido a que, como tal, no genera un error en tiempo de ejecución (ni de compilación), pero el resultado que uno obtiene varía en función de como el planificador a corto plazo va organizando estos procesos.

5. 

| Estrategía | Ocurrencia | Overhead                                                       | Flexibilidad |
| ---------- | ---------- | -------------------------------------------------------------- | ------------ |
| Evasión    | NO         | Mayor (si es que se piden recursos con mucha frecuencia)       | Menor        |
| Detección  | Puede      | Menor (si el tiempo entre ejecuciones del algoritmo es grande) | Absoluta     |
