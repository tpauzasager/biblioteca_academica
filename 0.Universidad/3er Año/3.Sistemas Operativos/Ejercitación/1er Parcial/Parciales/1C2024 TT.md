![[Pasted image 20241002113037.png]]
# Práctica

___
```cpp 
cola_sistema_limite = 50
mu_cola_sistema = 1
hay_encargo = 0

cola_seccion_limite = [10,10,10,10,10]
mu_cola_encargos = [1,1,1,1,1]
hay_deposito = [0,0,0,0,0] 

	### CLIENTE
while(1){
	artefacto_roto = obtener_artefacto_roto(lista_artefactos_del_cliente) //no es recurso compartido

	encargo = llevar_a_reparar(artefacto_roto)
	
	w(cola_sistema_limite)
	w(mu_cola_sistema)
	entregar_encargo(encargo.cola_sistema)
	s(mu_cola_sistema)
	s(hay_encargo)
}
	### Administrador
while(1){
	w(hay_encargo)
	w(mu_cola_sistema)
	encargo = retirar_encargo(cola_sistema)
	s(mu_cola_sistema)

	id_seccion = obtener_seccion_de(encargo) //no es recurso compartido (solo hay un admin)

	w(cola_seccion_limite[id_seccion])
	w(mu_cola_encargos[id_seccion])
	depositar(encargo.cola_encargos[id_seccion])
	s(mu_cola_encargos[id_seccion])
	s(cola_sistema_limite)
	s(hay_deposito[id_seccion])
}
	### Técnico
while(1){
	id_seccion = seccion_perteneciente(id_tecnico)
	w(hay_deposito[id_seccion])
	w(mu_cola_encargos[id_seccion])	
	encargo = tomar_encargo(cola_encargos[id_seccion])
	s(mu_cola_encargos[id_seccion])	

	reparar_artefacto(encargo)
	s(cola_seccion_limite[id_seccion])
}
```
___
# Teoría
1. 
	Las instrucciones privilegiadas son aquellas que requieren ser ejecutadas en modo kernel, por ende, no son accesibles por las aplicaciones de usuario. En cambio, las no privilegiadas, pueden ser ejecutadas desde cualquier modo. 
	El modo de ejecución kernel es aquel en el que se pueden ejecutar cualquier tipo de instrucción, en cambio, en el modo usuario, solo se disponen de una cantidad reducida de instrucciones que pueden ser ejecutadas con estos permisos. Así mismo, en cada modo se posee un contexto de ejecución diferente, por esto, si la cpu requiere ejecutar cierta instrucción en modo kernel (y actualmente se encuentra en modo usuario), tendrá que cambiar de contexto. 
2. 
	Para minimizar los cambios de modo, una aplicación debería implementar hilos de tipo kernel, ya que, si se requiere ejecutar una instrucción a nivel kernel, no será necesario cambiar de modo durante la ejecución de las demás instrucciones. 
	...
3. 
	La diferencia entre estos algoritmos radica en que, en los algoritmos con desalojo, dependiendo de la lógica por la cual se priorizan los procesos/hilos, en el momento que se detecta la llegada de un proceso/hilo con mayor prioridad este pasa a ser ejecutado, mientras que el que estaba ejeuctando anteriormente, pasa a estar nuevamente en la cola READY. En cambio, para los algoritmos sin desalojo, se espera que el proceso termine su rafaga de cpu antes de poner a ejecutar el nuevo proceso con mayor prioridad que recien llego a la cola READY. 
	Para evitar que un proceso monopolice la cpu, es decir, que utilice a la misma durante un periodo muy largo, sin dejar que el resto de los procesos puedan acceder a esta, es necesario utilizar algoritmos con desalojo, para que así, en el caso de que lleguen nuevos procesos más prioritarios, estos desalojen al proceso en ejecución.
4. 
	a. Verdadero. Suponiendo que nos intersa evitar la condición de carrera y que al menos uno de estos proceso quiera modificar dicho recurso, si es necesario implementar un asolución para asegurar la mutua exclusión y así evitar dicha condición.
	b. Falso. Si bien las **soluciones por software generar espera activa** (debido a que no pueden usar bloqueo), esto no significa que sean menos performantes, ya que, en el caso de contar con varias CPU y que la rafa de CPU promedio de los procesos sea baja, sería incluso mejor implementar una solución que implique espera activa, puesto que no se percibirá tanto overhead por los constantes cambios de contexto que una espera no activa generaría. 
5. 
	Para detectar un deadlock, se podría evaluar el uso de la CPU, la cantidad de procesos que se encuentran bloqueados (y por cuanto tiempo han permanecido en ese estado)
	En cambio, para el livelock, es más complicado poder detectarlos, ya que los procesos si se encuentran en ejecución, pero no avanzan. Por esto, sería necesario evaluar el PC de los procesos involucrados, de modo que si este permanece constante existe la posibilidad de que se encuentren en un livelock. 
	